from phantom_simulation.sinogram_simulator import SinogramSimulator
from pet_recon.castor_reconstructor import CastorPetReconstruction
from pytorcher.trainer.pytorch_trainer import PytorchTrainer

import matplotlib.pyplot as plt

from tools.image.castor import read_castor_binary_file
from tools.image.metrics import PSNR, SSIM

import torch
import numpy as np
import os
import copy

class SingleImageInferencePipeline(PytorchTrainer):

    def __init__(self, model_name, model_version,
                image_size=(256,256), voxel_size=(2,2,2), num_workers=4,
                dest_path='./', seed=42, binsimu=None, binrecon=None, metrics_configs=[]):

        self.image_size = image_size
        self.voxel_size = voxel_size
        self.num_workers = num_workers
        self.dest_path = dest_path
        self.seed = seed
        self.binrecon = binrecon if binrecon is not None else f"{os.getenv('WORKSPACE')}/castor_v3.2_bin/castor-recon_unix64"
        self.binsimu = binsimu if binsimu is not None else f"{os.getenv('WORKSPACE')}/simulator/bin"

        self.device = self.get_device()
        self.model = self.get_model(model_name, model_version, device=self.device)

        # add prefix for noisy reconstruction and denoised reconstruction metrics
        metrics_configs_ = []
        for metric_config in metrics_configs:
            metric_name = metric_config[0]
            metric_params = copy.deepcopy(metric_config[1])
            metric_params.update({'name': f'denoised_recon_{metric_name}'})
            metrics_configs_.append([metric_name, metric_params])
            metric_params = copy.deepcopy(metric_config[1])
            metric_params.update({'name': f'noisy_recon_{metric_name}'})
            metrics_configs_.append([metric_name, metric_params])

        self.metrics = self.get_metrics(metrics_configs_)
        # remove loss
        self.metrics = [m for m in self.metrics if m.name != 'loss']

    def get_model(self, model_name, model_version, device):
        """
        Load registered model from MLflow.
        """
        model_uri = f"models:/{model_name}/{model_version}"
        self.model = mlflow.pytorch.load_model(model_uri=model_uri, device=device)
        print(f"Loaded model '{model_name}' version {model_version} from MLflow.")
        self.model.eval()
        return self.model
    
    def set_image(self, img_path, img_att_path):
        """
        Set the image path for inference.
        """

        self.img_path = img_path
        self.img_att_path = img_att_path

    def normalize(self, tensor):
        """
        Normalize tensor to [0, 1].
        """
        min_val = torch.min(tensor)
        max_val = torch.max(tensor)
        tensor_norm = (tensor - min_val) / (max_val - min_val)
        return tensor_norm

    def get_simulator(self):
        self.sinogram_simulator = SinogramSimulator(binsimu=self.binsimu, save_castor=True, seed=self.seed)
        return self.sinogram_simulator

    def get_reconstructor(self):
        self.reconstructor = CastorPetReconstruction(
            binrecon=self.binrecon,
            binsimu=self.binsimu,
            fout="recon",
            verbose=1
        )
        return self.reconstructor

    def run_simulation(self):
        """
        Run sinogram simulation for the single image.
        """
        dest_path = os.path.join(self.dest_path)
        self.sinogram_simulator.run(
            img_path=self.img_path,
            img_att_path=self.img_att_path,
            dest_path=dest_path
        )

        # get noisy range from simulated data
        sinogram_data = np.fromfile(os.path.join(dest_path, 'simu', 'simu_pt.s'), dtype='<i2')
        self.noisy_range = sinogram_data.min(), sinogram_data.max()

    def overwrite_prompt_sinogram(self, sinogram):
        """
        Overwrite the prompt sinogram file with the given sinogram array.
        """

        # save denoised sinogram to file for reconstruction
        # the current prompt sinogram generated by the simulation process will be overwritten
        # This file is not used anyway as we compute poisson noise from the noise-free sinogram
        with open(os.path.join(self.dest_path, 'simu', 'simu_pt.s'), 'wb') as f:
            # ensure a CPU numpy array in little-endian 16-bit signed format and contiguous memory
            arr = sinogram.astype('<i2')
            f.write(arr.tobytes())

    def run_reconstruction(self, dest_path):
        """
        Run reconstruction for the single image sinogram.
        """
        # empty dest_path if exists
        if os.path.exists(dest_path):
            for file in os.listdir(dest_path):
                file_path = os.path.join(dest_path, file)
                if os.path.isfile(file_path):
                    os.remove(file_path)
        # 
        iterations = 10
        subsets = 16
        self.reconstructor.run(
            dest_path=dest_path,
            it=f"{iterations}:{subsets}",
            dim=(*self.image_size,1),
            voxel_size=self.voxel_size
        )

    def run(self):
        """
        Run the full inference pipeline for the single image.
        """

        # Get simulator and reconstructor
        self.get_simulator()
        self.get_reconstructor()

        # Run simulation
        self.run_simulation()

        # Run reconstruction for noisy sinogram
        dest_path_noisy = os.path.join(self.dest_path, 'recon_noisy')
        self.run_reconstruction(dest_path_noisy)

        # Read noisy sinogram
        sinogram_noisy = read_castor_binary_file(os.path.join(self.dest_path, 'simu', 'simu_pt.s.hdr'), reader='numpy')

        # Normalize noisy sinogram to [0, 1]
        sinogram_noisy_norm = self.normalize(torch.from_numpy(sinogram_noisy).float())

        # Perform denoising inference
        with torch.no_grad():
            sinogram_noisy_norm = sinogram_noisy_norm.to(self.device)
            if sinogram_noisy_norm.dim() == 3:
                sinogram_noisy_norm = sinogram_noisy_norm.unsqueeze(1)  # add channel dimension
            denoised_sinogram = self.model(sinogram_noisy_norm)
            denoised_sinogram = denoised_sinogram.cpu()

        # Transform it back to numpy array
        denoised_sinogram = denoised_sinogram.squeeze(1).numpy()

        # post-process denoised sinogram
        denoised_sinogram = np.clip(denoised_sinogram, 0, 1)
        denoised_sinogram = denoised_sinogram * (self.noisy_range[1] - self.noisy_range[0]) + self.noisy_range[0]
        denoised_sinogram = denoised_sinogram.round().astype(np.int16)

        # plot snograms
        fig, ax = plt.subplots(1,2)
        ax[0].imshow(sinogram_noisy.squeeze(), cmap='gray')
        ax[0].set_title('Noisy Sinogram')
        ax[1].imshow(denoised_sinogram.squeeze(), cmap='gray')
        ax[1].set_title('Denoised Sinogram')
        plt.savefig(os.path.join(self.dest_path, 'sinograms_comparison.png'), dpi=300)
        plt.show()

        # Overwrite prompt sinogram with denoised sinogram
        self.overwrite_prompt_sinogram(denoised_sinogram)

        # Run reconstruction for denoised sinogram
        dest_path_denoised = os.path.join(self.dest_path, 'recon_denoised')
        self.run_reconstruction(dest_path_denoised)

if __name__ == "__main__":

    import mlflow

    mlflow.set_tracking_uri(os.getenv("MLFLOW_TRACKING_URI"))

    dest_path = f"{os.getenv('WORKSPACE')}/data/brain_web_phantom"

    inference_pipeline = SingleImageInferencePipeline(
        model_name="Noise2Noise_2DPET_Model",
        model_version=10,
        metrics_configs=[
            ['PSNR', {}],
            ['SSIM', {}]
        ],
        image_size=(160,160),
        voxel_size=(2,2,2),
        dest_path=dest_path,
        seed=42,
        binsimu=f"{os.getenv('WORKSPACE')}/simulator/bin",
        num_workers=10
    )

    inference_pipeline.set_image(
        img_path=f"{os.getenv('WORKSPACE')}/data/brain_web_phantom/object/gt_web_after_scaling.hdr",
        img_att_path=f"{os.getenv('WORKSPACE')}/data/brain_web_phantom/object/attenuat_brain_phantom.hdr"
    )

    inference_pipeline.run()

    # # plot PSNR against iterations for noisy and denoised reconstruction
    # import matplotlib.pyplot as plt

    # # Read ground truth image
    # gt_image = read_castor_binary_file(os.path.join(dest_path, 'object', 'gt_web_after_scaling.hdr'), reader='numpy')
    
    # PSNRs_denoised = []
    # SSIMs_denoised = []
    # PSNRs_noisy = []
    # SSIMs_noisy = []
    # it = 1
    # while os.path.isfile(os.path.join(dest_path, 'recon_denoised', f'recon_it{it}.hdr')) and \
    #         os.path.isfile(os.path.join(dest_path, 'recon_noisy', f'recon_it{it}.hdr')):

    #     recon_denoised = read_castor_binary_file(os.path.join(dest_path, 'recon_denoised', f'recon_it{it}.hdr'), reader='numpy')
    #     recon_noisy = read_castor_binary_file(os.path.join(dest_path, 'recon_noisy', f'recon_it{it}.hdr'), reader='numpy')

    #     PSNR_denoised = PSNR(I=gt_image, K=recon_denoised)
    #     PSNR_noisy = PSNR(I=gt_image, K=recon_noisy)

    #     SSIM_denoised = SSIM(img1=gt_image, img2=recon_denoised)
    #     SSIM_noisy = SSIM(img1=gt_image, img2=recon_noisy)

    #     PSNRs_denoised.append(PSNR_denoised)
    #     PSNRs_noisy.append(PSNR_noisy)
    #     SSIMs_denoised.append(SSIM_denoised)
    #     SSIMs_noisy.append(SSIM_noisy)

    #     it += 1

    # fig, ax1 = plt.subplots()
    # ax1.plot(range(1, it), PSNRs_denoised, label='Denoised Reconstruction PSNR', color='black')
    # ax1.plot(range(1, it), PSNRs_noisy, label='Noisy Reconstruction PSNR', color=(0/255, 102/255, 204/255))

    # ax1.set_xlabel('Iterations')
    # ax1.set_ylabel('PSNR (dB)')


    # ax2 = ax1.twinx()
    # ax2.plot(range(1, it), SSIMs_denoised, label='Denoised Reconstruction SSIM', linestyle='--', color='black')
    # ax2.plot(range(1, it), SSIMs_noisy, label='Noisy Reconstruction SSIM', linestyle='--', color=(0/255, 102/255, 204/255))
    # ax2.set_xlabel('Iterations')
    # ax2.set_ylabel('SSIM')
    # ax2.set_xlabel('Iterations')
    # plt.suptitle('PSNR and SSIM vs Iterations for Noisy and Denoised Reconstruction')
    # # legend
    # lines_1, labels_1 = ax1.get_legend_handles_labels()
    # lines_2, labels_2 = ax2.get_legend_handles_labels()
    # ax1.legend(lines_1 + lines_2, labels_1 + labels_2)
    # ax1.grid()
    # plt.savefig(os.path.join(dest_path, 'psnr_vs_iterations_OSEM.png'))
    
    # def plot_reconstructions_at_it(it):
    #     if isinstance(it, int):
    #         it = (it, it)
    #     fig, ax = plt.subplots(1,2, figsize=(10,5))
    #     recon_denoised_last = np.squeeze(read_castor_binary_file(os.path.join(dest_path, 'recon_denoised', f'recon_it{it[0]}.hdr'), reader='numpy'))
    #     recon_noisy_last = np.squeeze(read_castor_binary_file(os.path.join(dest_path, 'recon_noisy', f'recon_it{it[1]}.hdr'), reader='numpy'))

    #     ax[0].imshow(recon_denoised_last, cmap='gray')
    #     ax[0].set_title(f'Denoised Reconstruction at iteration ({it[0]})\nPSNR: {PSNRs_denoised[-1]:.2f} dB, SSIM: {SSIMs_denoised[-1]:.4f}')
    #     ax[0].axis('off')

    #     ax[1].imshow(recon_noisy_last, cmap='gray')
    #     ax[1].set_title(f'Noisy Reconstruction at iteration ({it[1]})\nPSNR: {PSNRs_noisy[-1]:.2f} dB, SSIM: {SSIMs_noisy[-1]:.4f}')
    #     ax[1].axis('off')

    #     plt.savefig(os.path.join(dest_path, f'recon_images_{it}_OSEM.png'))



    # plot_reconstructions_at_it(it-1) # last iteration
    # denoised_optimal_it = int(np.argmax(PSNRs_denoised) + 1)
    # noisy_optimal_it = int(np.argmax(PSNRs_noisy) + 1)
    # plot_reconstructions_at_it((denoised_optimal_it, noisy_optimal_it)) # optimal iteration based on PSNR